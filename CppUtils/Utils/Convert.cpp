#include "Convert.h"
#include <Windows.h>
#include <iomanip>
#include <iostream>
#include <sstream>
#include "MD5.h"
#include "SHA256.h"

#include <vector>
#include <string>
#include <cstring>
#include <cassert>

#pragma warning(disable: 4267)
#pragma warning(disable: 4244)
#pragma warning(disable: 4018)

static constexpr const uint16_t hexTable[] = {
	0x3030,0x3130,0x3230,0x3330,0x3430,0x3530,0x3630,0x3730,0x3830,0x3930,0x4130,0x4230,0x4330,0x4430,0x4530,0x4630,
	0x3031,0x3131,0x3231,0x3331,0x3431,0x3531,0x3631,0x3731,0x3831,0x3931,0x4131,0x4231,0x4331,0x4431,0x4531,0x4631,
	0x3032,0x3132,0x3232,0x3332,0x3432,0x3532,0x3632,0x3732,0x3832,0x3932,0x4132,0x4232,0x4332,0x4432,0x4532,0x4632,
	0x3033,0x3133,0x3233,0x3333,0x3433,0x3533,0x3633,0x3733,0x3833,0x3933,0x4133,0x4233,0x4333,0x4433,0x4533,0x4633,
	0x3034,0x3134,0x3234,0x3334,0x3434,0x3534,0x3634,0x3734,0x3834,0x3934,0x4134,0x4234,0x4334,0x4434,0x4534,0x4634,
	0x3035,0x3135,0x3235,0x3335,0x3435,0x3535,0x3635,0x3735,0x3835,0x3935,0x4135,0x4235,0x4335,0x4435,0x4535,0x4635,
	0x3036,0x3136,0x3236,0x3336,0x3436,0x3536,0x3636,0x3736,0x3836,0x3936,0x4136,0x4236,0x4336,0x4436,0x4536,0x4636,
	0x3037,0x3137,0x3237,0x3337,0x3437,0x3537,0x3637,0x3737,0x3837,0x3937,0x4137,0x4237,0x4337,0x4437,0x4537,0x4637,
	0x3038,0x3138,0x3238,0x3338,0x3438,0x3538,0x3638,0x3738,0x3838,0x3938,0x4138,0x4238,0x4338,0x4438,0x4538,0x4638,
	0x3039,0x3139,0x3239,0x3339,0x3439,0x3539,0x3639,0x3739,0x3839,0x3939,0x4139,0x4239,0x4339,0x4439,0x4539,0x4639,
	0x3041,0x3141,0x3241,0x3341,0x3441,0x3541,0x3641,0x3741,0x3841,0x3941,0x4141,0x4241,0x4341,0x4441,0x4541,0x4641,
	0x3042,0x3142,0x3242,0x3342,0x3442,0x3542,0x3642,0x3742,0x3842,0x3942,0x4142,0x4242,0x4342,0x4442,0x4542,0x4642,
	0x3043,0x3143,0x3243,0x3343,0x3443,0x3543,0x3643,0x3743,0x3843,0x3943,0x4143,0x4243,0x4343,0x4443,0x4543,0x4643,
	0x3044,0x3144,0x3244,0x3344,0x3444,0x3544,0x3644,0x3744,0x3844,0x3944,0x4144,0x4244,0x4344,0x4444,0x4544,0x4644,
	0x3045,0x3145,0x3245,0x3345,0x3445,0x3545,0x3645,0x3745,0x3845,0x3945,0x4145,0x4245,0x4345,0x4445,0x4545,0x4645,
	0x3046,0x3146,0x3246,0x3346,0x3446,0x3546,0x3646,0x3746,0x3846,0x3946,0x4146,0x4246,0x4346,0x4446,0x4546,0x4646,
};
static constexpr const uint32_t hexTableW[] = {
	0x300030,0x310030,0x320030,0x330030,0x340030,0x350030,0x360030,0x370030,0x380030,0x390030,0x410030,0x420030,0x430030,0x440030,0x450030,0x460030,
	0x300031,0x310031,0x320031,0x330031,0x340031,0x350031,0x360031,0x370031,0x380031,0x390031,0x410031,0x420031,0x430031,0x440031,0x450031,0x460031,
	0x300032,0x310032,0x320032,0x330032,0x340032,0x350032,0x360032,0x370032,0x380032,0x390032,0x410032,0x420032,0x430032,0x440032,0x450032,0x460032,
	0x300033,0x310033,0x320033,0x330033,0x340033,0x350033,0x360033,0x370033,0x380033,0x390033,0x410033,0x420033,0x430033,0x440033,0x450033,0x460033,
	0x300034,0x310034,0x320034,0x330034,0x340034,0x350034,0x360034,0x370034,0x380034,0x390034,0x410034,0x420034,0x430034,0x440034,0x450034,0x460034,
	0x300035,0x310035,0x320035,0x330035,0x340035,0x350035,0x360035,0x370035,0x380035,0x390035,0x410035,0x420035,0x430035,0x440035,0x450035,0x460035,
	0x300036,0x310036,0x320036,0x330036,0x340036,0x350036,0x360036,0x370036,0x380036,0x390036,0x410036,0x420036,0x430036,0x440036,0x450036,0x460036,
	0x300037,0x310037,0x320037,0x330037,0x340037,0x350037,0x360037,0x370037,0x380037,0x390037,0x410037,0x420037,0x430037,0x440037,0x450037,0x460037,
	0x300038,0x310038,0x320038,0x330038,0x340038,0x350038,0x360038,0x370038,0x380038,0x390038,0x410038,0x420038,0x430038,0x440038,0x450038,0x460038,
	0x300039,0x310039,0x320039,0x330039,0x340039,0x350039,0x360039,0x370039,0x380039,0x390039,0x410039,0x420039,0x430039,0x440039,0x450039,0x460039,
	0x300041,0x310041,0x320041,0x330041,0x340041,0x350041,0x360041,0x370041,0x380041,0x390041,0x410041,0x420041,0x430041,0x440041,0x450041,0x460041,
	0x300042,0x310042,0x320042,0x330042,0x340042,0x350042,0x360042,0x370042,0x380042,0x390042,0x410042,0x420042,0x430042,0x440042,0x450042,0x460042,
	0x300043,0x310043,0x320043,0x330043,0x340043,0x350043,0x360043,0x370043,0x380043,0x390043,0x410043,0x420043,0x430043,0x440043,0x450043,0x460043,
	0x300044,0x310044,0x320044,0x330044,0x340044,0x350044,0x360044,0x370044,0x380044,0x390044,0x410044,0x420044,0x430044,0x440044,0x450044,0x460044,
	0x300045,0x310045,0x320045,0x330045,0x340045,0x350045,0x360045,0x370045,0x380045,0x390045,0x410045,0x420045,0x430045,0x440045,0x450045,0x460045,
	0x300046,0x310046,0x320046,0x330046,0x340046,0x350046,0x360046,0x370046,0x380046,0x390046,0x410046,0x420046,0x430046,0x440046,0x450046,0x460046,
};
static constexpr const uint8_t base64_table[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x3F,
	0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,
	0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
	0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
static constexpr const uint8_t base85_table[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,
	0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,
	0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,
	0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,
	0x3F,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,
	0x4F,0x50,0x51,0x52,0x53,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
static constexpr const uint8_t hex_table_str[] = {
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
	0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
};
std::string Convert::ToHex(const uint8_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(2, '\0');
	output[0x1] = keyTable[(*(uint8_t*)&input & 0x0F) >> 0x00];
	output[0x0] = keyTable[(*(uint8_t*)&input & 0xF0) >> 0x04];
	return output;
}
std::string Convert::ToHex(const int8_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(2, '\0');
	output[0x1] = keyTable[(*(uint8_t*)&input & 0x0F) >> 0x00];
	output[0x0] = keyTable[(*(uint8_t*)&input & 0xF0) >> 0x04];
	return output;
}
std::wstring Convert::ToHexW(const uint8_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(2, '\0');
	output[0x1] = keyTable[(*(uint8_t*)&input & 0x0F) >> 0x00];
	output[0x0] = keyTable[(*(uint8_t*)&input & 0xF0) >> 0x04];
	return output;
}
std::wstring Convert::ToHexW(const int8_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(2, '\0');
	output[0x1] = keyTable[(*(uint8_t*)&input & 0x0F) >> 0x00];
	output[0x0] = keyTable[(*(uint8_t*)&input & 0xF0) >> 0x04];
	return output;
}
std::string Convert::ToHex(const uint16_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(4, '\0');
	output[0x3] = keyTable[(*(uint16_t*)&input & 0x000F) >> 0x00];
	output[0x2] = keyTable[(*(uint16_t*)&input & 0x00F0) >> 0x04];
	output[0x1] = keyTable[(*(uint16_t*)&input & 0x0F00) >> 0x08];
	output[0x0] = keyTable[(*(uint16_t*)&input & 0xF000) >> 0x0C];
	return output;
}
std::string Convert::ToHex(const int16_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(4, '\0');
	output[0x3] = keyTable[(*(uint16_t*)&input & 0x000F) >> 0x00];
	output[0x2] = keyTable[(*(uint16_t*)&input & 0x00F0) >> 0x04];
	output[0x1] = keyTable[(*(uint16_t*)&input & 0x0F00) >> 0x08];
	output[0x0] = keyTable[(*(uint16_t*)&input & 0xF000) >> 0x0C];
	return output;
}
std::wstring Convert::ToHexW(const uint16_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(4, '\0');
	output[0x3] = keyTable[(*(uint16_t*)&input & 0x000F) >> 0x00];
	output[0x2] = keyTable[(*(uint16_t*)&input & 0x00F0) >> 0x04];
	output[0x1] = keyTable[(*(uint16_t*)&input & 0x0F00) >> 0x08];
	output[0x0] = keyTable[(*(uint16_t*)&input & 0xF000) >> 0x0C];
	return output;
}
std::wstring Convert::ToHexW(const int16_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(4, '\0');
	output[0x3] = keyTable[(*(uint16_t*)&input & 0x000F) >> 0x00];
	output[0x2] = keyTable[(*(uint16_t*)&input & 0x00F0) >> 0x04];
	output[0x1] = keyTable[(*(uint16_t*)&input & 0x0F00) >> 0x08];
	output[0x0] = keyTable[(*(uint16_t*)&input & 0xF000) >> 0x0C];
	return output;
}
std::string Convert::ToHex(const uint32_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(8, '\0');
	output[0x7] = keyTable[(*(uint32_t*)&input & 0x0000000F) >> 0x00];
	output[0x6] = keyTable[(*(uint32_t*)&input & 0x000000F0) >> 0x04];
	output[0x5] = keyTable[(*(uint32_t*)&input & 0x00000F00) >> 0x08];
	output[0x4] = keyTable[(*(uint32_t*)&input & 0x0000F000) >> 0x0C];
	output[0x3] = keyTable[(*(uint32_t*)&input & 0x000F0000) >> 0x10];
	output[0x2] = keyTable[(*(uint32_t*)&input & 0x00F00000) >> 0x14];
	output[0x1] = keyTable[(*(uint32_t*)&input & 0x0F000000) >> 0x18];
	output[0x0] = keyTable[(*(uint32_t*)&input & 0xF0000000) >> 0x1C];
	return output;
}
std::string Convert::ToHex(const int32_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(8, '\0');
	output[0x7] = keyTable[(*(uint32_t*)&input & 0x0000000F) >> 0x00];
	output[0x6] = keyTable[(*(uint32_t*)&input & 0x000000F0) >> 0x04];
	output[0x5] = keyTable[(*(uint32_t*)&input & 0x00000F00) >> 0x08];
	output[0x4] = keyTable[(*(uint32_t*)&input & 0x0000F000) >> 0x0C];
	output[0x3] = keyTable[(*(uint32_t*)&input & 0x000F0000) >> 0x10];
	output[0x2] = keyTable[(*(uint32_t*)&input & 0x00F00000) >> 0x14];
	output[0x1] = keyTable[(*(uint32_t*)&input & 0x0F000000) >> 0x18];
	output[0x0] = keyTable[(*(uint32_t*)&input & 0xF0000000) >> 0x1C];
	return output;
}
std::wstring Convert::ToHexW(const uint32_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(8, '\0');
	output[0x7] = keyTable[(*(uint32_t*)&input & 0x0000000F) >> 0x00];
	output[0x6] = keyTable[(*(uint32_t*)&input & 0x000000F0) >> 0x04];
	output[0x5] = keyTable[(*(uint32_t*)&input & 0x00000F00) >> 0x08];
	output[0x4] = keyTable[(*(uint32_t*)&input & 0x0000F000) >> 0x0C];
	output[0x3] = keyTable[(*(uint32_t*)&input & 0x000F0000) >> 0x10];
	output[0x2] = keyTable[(*(uint32_t*)&input & 0x00F00000) >> 0x14];
	output[0x1] = keyTable[(*(uint32_t*)&input & 0x0F000000) >> 0x18];
	output[0x0] = keyTable[(*(uint32_t*)&input & 0xF0000000) >> 0x1C];
	return output;
}
std::wstring Convert::ToHexW(const int32_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(8, '\0');
	output[0x7] = keyTable[(*(uint32_t*)&input & 0x0000000F) >> 0x00];
	output[0x6] = keyTable[(*(uint32_t*)&input & 0x000000F0) >> 0x04];
	output[0x5] = keyTable[(*(uint32_t*)&input & 0x00000F00) >> 0x08];
	output[0x4] = keyTable[(*(uint32_t*)&input & 0x0000F000) >> 0x0C];
	output[0x3] = keyTable[(*(uint32_t*)&input & 0x000F0000) >> 0x10];
	output[0x2] = keyTable[(*(uint32_t*)&input & 0x00F00000) >> 0x14];
	output[0x1] = keyTable[(*(uint32_t*)&input & 0x0F000000) >> 0x18];
	output[0x0] = keyTable[(*(uint32_t*)&input & 0xF0000000) >> 0x1C];
	return output;
}
std::string Convert::ToHex(const uint64_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(16, '\0');
	output[0xF] = keyTable[(*(uint64_t*)&input & 0x000000000000000F) >> 0x00];
	output[0xE] = keyTable[(*(uint64_t*)&input & 0x00000000000000F0) >> 0x04];
	output[0xD] = keyTable[(*(uint64_t*)&input & 0x0000000000000F00) >> 0x08];
	output[0xC] = keyTable[(*(uint64_t*)&input & 0x000000000000F000) >> 0x0C];
	output[0xB] = keyTable[(*(uint64_t*)&input & 0x00000000000F0000) >> 0x10];
	output[0xA] = keyTable[(*(uint64_t*)&input & 0x0000000000F00000) >> 0x14];
	output[0x9] = keyTable[(*(uint64_t*)&input & 0x000000000F000000) >> 0x18];
	output[0x8] = keyTable[(*(uint64_t*)&input & 0x00000000F0000000) >> 0x1C];
	output[0x7] = keyTable[(*(uint64_t*)&input & 0x0000000F00000000) >> 0x20];
	output[0x6] = keyTable[(*(uint64_t*)&input & 0x000000F000000000) >> 0x24];
	output[0x5] = keyTable[(*(uint64_t*)&input & 0x00000F0000000000) >> 0x28];
	output[0x4] = keyTable[(*(uint64_t*)&input & 0x0000F00000000000) >> 0x2C];
	output[0x3] = keyTable[(*(uint64_t*)&input & 0x000F000000000000) >> 0x30];
	output[0x2] = keyTable[(*(uint64_t*)&input & 0x00F0000000000000) >> 0x34];
	output[0x1] = keyTable[(*(uint64_t*)&input & 0x0F00000000000000) >> 0x38];
	output[0x0] = keyTable[(*(uint64_t*)&input & 0xF000000000000000) >> 0x3C];
	return output;
}
std::string Convert::ToHex(const int64_t input) {
	const char keyTable[] = "0123456789ABCDEF";
	std::string output(16, '\0');
	output[0xF] = keyTable[(*(uint64_t*)&input & 0x000000000000000F) >> 0x00];
	output[0xE] = keyTable[(*(uint64_t*)&input & 0x00000000000000F0) >> 0x04];
	output[0xD] = keyTable[(*(uint64_t*)&input & 0x0000000000000F00) >> 0x08];
	output[0xC] = keyTable[(*(uint64_t*)&input & 0x000000000000F000) >> 0x0C];
	output[0xB] = keyTable[(*(uint64_t*)&input & 0x00000000000F0000) >> 0x10];
	output[0xA] = keyTable[(*(uint64_t*)&input & 0x0000000000F00000) >> 0x14];
	output[0x9] = keyTable[(*(uint64_t*)&input & 0x000000000F000000) >> 0x18];
	output[0x8] = keyTable[(*(uint64_t*)&input & 0x00000000F0000000) >> 0x1C];
	output[0x7] = keyTable[(*(uint64_t*)&input & 0x0000000F00000000) >> 0x20];
	output[0x6] = keyTable[(*(uint64_t*)&input & 0x000000F000000000) >> 0x24];
	output[0x5] = keyTable[(*(uint64_t*)&input & 0x00000F0000000000) >> 0x28];
	output[0x4] = keyTable[(*(uint64_t*)&input & 0x0000F00000000000) >> 0x2C];
	output[0x3] = keyTable[(*(uint64_t*)&input & 0x000F000000000000) >> 0x30];
	output[0x2] = keyTable[(*(uint64_t*)&input & 0x00F0000000000000) >> 0x34];
	output[0x1] = keyTable[(*(uint64_t*)&input & 0x0F00000000000000) >> 0x38];
	output[0x0] = keyTable[(*(uint64_t*)&input & 0xF000000000000000) >> 0x3C];
	return output;
}
std::wstring Convert::ToHexW(const uint64_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(16, '\0');
	output[0xF] = keyTable[(*(uint64_t*)&input & 0x000000000000000F) >> 0x00];
	output[0xE] = keyTable[(*(uint64_t*)&input & 0x00000000000000F0) >> 0x04];
	output[0xD] = keyTable[(*(uint64_t*)&input & 0x0000000000000F00) >> 0x08];
	output[0xC] = keyTable[(*(uint64_t*)&input & 0x000000000000F000) >> 0x0C];
	output[0xB] = keyTable[(*(uint64_t*)&input & 0x00000000000F0000) >> 0x10];
	output[0xA] = keyTable[(*(uint64_t*)&input & 0x0000000000F00000) >> 0x14];
	output[0x9] = keyTable[(*(uint64_t*)&input & 0x000000000F000000) >> 0x18];
	output[0x8] = keyTable[(*(uint64_t*)&input & 0x00000000F0000000) >> 0x1C];
	output[0x7] = keyTable[(*(uint64_t*)&input & 0x0000000F00000000) >> 0x20];
	output[0x6] = keyTable[(*(uint64_t*)&input & 0x000000F000000000) >> 0x24];
	output[0x5] = keyTable[(*(uint64_t*)&input & 0x00000F0000000000) >> 0x28];
	output[0x4] = keyTable[(*(uint64_t*)&input & 0x0000F00000000000) >> 0x2C];
	output[0x3] = keyTable[(*(uint64_t*)&input & 0x000F000000000000) >> 0x30];
	output[0x2] = keyTable[(*(uint64_t*)&input & 0x00F0000000000000) >> 0x34];
	output[0x1] = keyTable[(*(uint64_t*)&input & 0x0F00000000000000) >> 0x38];
	output[0x0] = keyTable[(*(uint64_t*)&input & 0xF000000000000000) >> 0x3C];
	return output;
}
std::wstring Convert::ToHexW(const int64_t input) {
	const wchar_t keyTable[] = L"0123456789ABCDEF";
	std::wstring output(16, '\0');
	output[0xF] = keyTable[(*(uint64_t*)&input & 0x000000000000000F) >> 0x00];
	output[0xE] = keyTable[(*(uint64_t*)&input & 0x00000000000000F0) >> 0x04];
	output[0xD] = keyTable[(*(uint64_t*)&input & 0x0000000000000F00) >> 0x08];
	output[0xC] = keyTable[(*(uint64_t*)&input & 0x000000000000F000) >> 0x0C];
	output[0xB] = keyTable[(*(uint64_t*)&input & 0x00000000000F0000) >> 0x10];
	output[0xA] = keyTable[(*(uint64_t*)&input & 0x0000000000F00000) >> 0x14];
	output[0x9] = keyTable[(*(uint64_t*)&input & 0x000000000F000000) >> 0x18];
	output[0x8] = keyTable[(*(uint64_t*)&input & 0x00000000F0000000) >> 0x1C];
	output[0x7] = keyTable[(*(uint64_t*)&input & 0x0000000F00000000) >> 0x20];
	output[0x6] = keyTable[(*(uint64_t*)&input & 0x000000F000000000) >> 0x24];
	output[0x5] = keyTable[(*(uint64_t*)&input & 0x00000F0000000000) >> 0x28];
	output[0x4] = keyTable[(*(uint64_t*)&input & 0x0000F00000000000) >> 0x2C];
	output[0x3] = keyTable[(*(uint64_t*)&input & 0x000F000000000000) >> 0x30];
	output[0x2] = keyTable[(*(uint64_t*)&input & 0x00F0000000000000) >> 0x34];
	output[0x1] = keyTable[(*(uint64_t*)&input & 0x0F00000000000000) >> 0x38];
	output[0x0] = keyTable[(*(uint64_t*)&input & 0xF000000000000000) >> 0x3C];
	return output;
}
std::string Convert::ToHex(const void* input, size_t size) {
	std::string result(size * 2, '\0');
	uint16_t* rTmp = (uint16_t*)&result[0];
	uint8_t* rVal = (uint8_t*)input;
	while (size--)
		*rTmp++ = hexTable[*rVal++];
	return result;
}
std::wstring Convert::ToHexW(const void* input, size_t size) {
	std::wstring result(size * 2, '\0');
	uint32_t* rTmp = (uint32_t*)&result[0];
	uint8_t* rVal = (uint8_t*)input;
	while (size--)
		*rTmp++ = *(uint32_t*)&hexTableW[*rVal++];
	return result;
}
std::vector<uint8_t> Convert::FromHex(const std::string hex) {
	std::vector<uint8_t> result = std::vector<uint8_t>();
	uint8_t _highBits = 0;
	bool ish = true;
	for (const char& c : hex) {
		uint8_t v = hex_table_str[c];
		if (v == 0x10) {
			if (!ish) {
				result.push_back(_highBits);
				ish = true;
			}
			continue;
		}
		if (ish)
			_highBits = v;
		else
			result.push_back((_highBits << 4) | v);
		ish = !ish;
	}
	if (!ish)
		result.push_back(_highBits);
	return result;

}
std::vector<uint8_t> Convert::FromHex(const std::wstring hex) {
	std::vector<uint8_t> result = std::vector<uint8_t>();
	uint8_t _highBits = 0;
	bool ish = true;
	for (const wchar_t& c : hex) {
		if (c > 0xFF)
			continue;
		uint8_t v = hex_table_str[c];
		if (v == 0x10) {
			if (!ish) {
				result.push_back(_highBits);
				ish = true;
			}
			continue;
		}
		if (ish)
			_highBits = v;
		else
			result.push_back((_highBits << 4) | v);
		ish = !ish;
	}
	if (!ish)
		result.push_back(_highBits);
	return result;

}
std::wstring Convert::MultiByteToWide(const std::string& str, uint32_t codePage) {
	int len = MultiByteToWideChar(codePage, 0, str.c_str(), static_cast<int>(str.length()), NULL, 0);
	std::wstring wstr(len, L'\0');
	MultiByteToWideChar(codePage, 0, str.c_str(), static_cast<int>(str.length()), &wstr[0], len);
	return wstr;
}
std::string Convert::WideToMultiByte(const std::wstring& wstr, uint32_t codePage) {
	int len = ::WideCharToMultiByte(codePage, 0, wstr.c_str(), static_cast<int>(wstr.length()), NULL, 0, NULL, NULL);
	std::string str(len, '\0');
	WideCharToMultiByte(codePage, 0, wstr.c_str(), static_cast<int>(wstr.length()), &str[0], len, NULL, NULL);
	return str;
}
std::string Convert::AnsiToUtf8(const std::string str) {
	std::wstring wstr = MultiByteToWide(str, CP_ACP);
	return WideToMultiByte(wstr, CP_UTF8);
}
std::string Convert::Utf8ToAnsi(const std::string str) {
	std::wstring wstr = MultiByteToWide(str, CP_UTF8);
	return WideToMultiByte(wstr, CP_ACP);
}
std::u16string Convert::Utf8ToUtf16(const std::string utf8Str) {
	std::wstring wideStr = MultiByteToWide(utf8Str, CP_UTF8);
	return std::u16string(wideStr.begin(), wideStr.end());
}
std::string Convert::Utf16ToUtf8(const std::u16string utf16Str) {
	std::wstring wideStr(utf16Str.begin(), utf16Str.end());
	return WideToMultiByte(wideStr, CP_UTF8);
}
std::u32string Convert::Utf8ToUtf32(const std::string utf8Str) {
	std::wstring wideStr = MultiByteToWide(utf8Str, CP_UTF8);
	return std::u32string(wideStr.begin(), wideStr.end());
}
std::string Convert::Utf32ToUtf8(const std::u32string utf32Str) {
	std::wstring wideStr(utf32Str.begin(), utf32Str.end());
	return WideToMultiByte(wideStr, CP_UTF8);
}
std::wstring Convert::AnsiToUnicode(const std::string ansiStr) {
	return MultiByteToWide(ansiStr, CP_ACP);
}
std::string Convert::UnicodeToAnsi(const std::wstring unicodeStr) {
	return WideToMultiByte(unicodeStr, CP_ACP);
}
std::wstring Convert::Utf8ToUnicode(const std::string utf8Str) {
	return MultiByteToWide(utf8Str, CP_UTF8);
}
std::string Convert::UnicodeToUtf8(const std::wstring unicodeStr) {
	return WideToMultiByte(unicodeStr, CP_UTF8);
}
std::string Convert::wstring_to_string(const std::wstring wstr) {
	return WideToMultiByte(wstr, CP_ACP);
}
std::wstring Convert::string_to_wstring(const std::string str) {
	return MultiByteToWide(str, CP_ACP);
}
std::string Convert::ToBase64(const void* data, size_t size) {
	static const char base64_chars[] =
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz"
		"0123456789+/";
	uint8_t* input = (uint8_t*)data;
	std::string output(((size + 2) / 3) * 4, '\0');

	int char_count = 0;
	uint8_t char_array_3[4] = { 0 };
	char char_array_4[4] = { 0 };
	size_t index = 0;
	while (size-- > 0) {
		char_array_3[char_count++] = *input++;
		if (char_count == 3) {
			char_array_4[0] = base64_chars[(char_array_3[0] & 0xFC) >> 2];
			char_array_4[1] = base64_chars[((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xF0) >> 4)];
			char_array_4[2] = base64_chars[((char_array_3[1] & 0x0F) << 2) + ((char_array_3[2] & 0xC0) >> 6)];
			char_array_4[3] = base64_chars[char_array_3[2] & 0x3F];
			*(uint32_t*)&output[index] = *(uint32_t*)char_array_4;
			index += 4;
			char_count = 0;
		}
	}

	if (char_count > 0) {
		*(uint32_t*)&char_array_3 = 0;
		char_array_4[0] = base64_chars[(char_array_3[0] & 0xFC) >> 2];
		char_array_4[1] = base64_chars[((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xF0) >> 4)];
		char_array_4[2] = base64_chars[((char_array_3[1] & 0x0F) << 2) + ((char_array_3[2] & 0xC0) >> 6)];
		char_array_4[3] = base64_chars[char_array_3[2] & 0x3F];

		for (int i = 0; i < char_count + 1; i++)
			output[index++] = char_array_4[i];

		while (char_count++ < 3)
			output[index++] = '=';
	}

	return output;
}
std::string Convert::ToBase64(const std::vector<uint8_t>& input) {
	return Convert::ToBase64(input.data(), input.size());
}
std::string Convert::ToBase64(const std::string input) {
	return Convert::ToBase64(input.data(), input.size());
}
std::string Convert::FromBase64(const std::string input) {
	size_t input_length = input.size();
	size_t output_length = (input_length / 4) * 3;

	if (input[input_length - 1] == '=') output_length--;
	if (input[input_length - 2] == '=') output_length--;

	std::string output(output_length, '\0');

	int char_count = 0;
	uint8_t char_array_4[4] = { 0 };
	uint8_t char_array_3[4] = { 0 };
	size_t index = 0;
	for (const char& c : input) {
		char_array_4[char_count++] = base64_table[c];
		if (char_count == 4) {
			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
			char_array_3[1] = ((char_array_4[1] & 0xF) << 4) + ((char_array_4[2] & 0x3C) >> 2);
			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

			*(uint32_t*)&output[index] = *(uint32_t*)char_array_3;
			index += 3;
			char_count = 0;
		}
	}

	if (char_count > 0) {
		*(uint32_t*)&char_array_4 = 0;
		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		char_array_3[1] = ((char_array_4[1] & 0xF) << 4) + ((char_array_4[2] & 0x3C) >> 2);
		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

		for (int i = 0; i < char_count - 1; i++) {
			output[index++] = char_array_3[i];
		}
	}

	return output;
}
std::vector<uint8_t> Convert::FromBase64ToBytes(const std::string input) {
	auto tmp = FromBase64(input);
	return std::vector<uint8_t>((uint8_t*)&tmp[0], (uint8_t*)&tmp[0] + tmp.size());
}
std::string Convert::ToBase85(const std::string input) {
	static const char base85_chars[] =
		"!\"#$%&'()*+,-./0123456789:;<=>?@"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"[\\]^_`abcdefghijklmnopqrstu";

	size_t input_length = input.size();
	size_t output_length = ((input_length + 3) / 4) * 5;
	std::string output(output_length, '\0');

	uint8_t char_array_4[4] = { 0 };
	char char_array_5[5] = { 0 };
	size_t index = 0;
	int char_count = 0;

	for (const uint8_t& c : input) {
		char_array_4[char_count++] = c;
		if (char_count == 4) {
			uint32_t value =
				(uint32_t(char_array_4[0]) << 24) |
				(uint32_t(char_array_4[1]) << 16) |
				(uint32_t(char_array_4[2]) << 8) |
				uint32_t(char_array_4[3]);

			if (value == 0) {
				output[index++] = 'z';
			}
			else {
				for (int i = 4; i >= 0; --i) {
					char_array_5[i] = base85_chars[value % 85];
					value /= 85;
				}
				*(uint32_t*)&output[index] = *(uint32_t*)char_array_5;
				output[index + 4] = char_array_5[4];
				index += 5;
			}
			char_count = 0;
			*(uint32_t*)char_array_4 = 0;
		}
	}

	if (char_count > 0) {
		for (int i = char_count; i < 4; ++i)
			char_array_4[i] = 0;
		uint32_t value =
			(uint32_t(char_array_4[0]) << 24) |
			(uint32_t(char_array_4[1]) << 16) |
			(uint32_t(char_array_4[2]) << 8) |
			uint32_t(char_array_4[3]);

		for (int i = 4; i >= 0; --i) {
			char_array_5[i] = base85_chars[value % 85];
			value /= 85;
		}
		for (int i = 0; i < char_count + 1; ++i) {
			output[index++] = char_array_5[i];
		}
	}

	output.resize(index);
	return output;
}
std::string Convert::FromBase85(const std::string input) {
	size_t input_length = input.size();
	size_t output_length = ((input_length + 4) / 5) * 4;
	std::string output(output_length, '\0');

	uint8_t char_array_5[5] = { 0 };
	uint8_t char_array_4[4] = { 0 };
	size_t index = 0;
	int char_count = 0;

	for (size_t i = 0; i < input_length; ++i) {
		if (input[i] == 'z') {
			*(uint32_t*)&output[index] = *(uint32_t*)char_array_4 = 0;
			index += 4;
			continue;
		}

		char_array_5[char_count++] = base85_table[(uint8_t)input[i]];
		if (char_count == 5) {
			uint32_t value = 0;
			for (int j = 0; j < 5; ++j) {
				value = value * 85 + char_array_5[j];
			}
			char_array_4[0] = (value >> 24) & 0xFF;
			char_array_4[1] = (value >> 16) & 0xFF;
			char_array_4[2] = (value >> 8) & 0xFF;
			char_array_4[3] = value & 0xFF;
			*(uint32_t*)&output[index] = *(uint32_t*)char_array_4;
			index += 4;
			char_count = 0;
		}
	}

	if (char_count > 0) {
		*(uint32_t*)char_array_5 = 0x54545454;
		char_array_5[4] = 0x54;
		uint32_t value = 0;
		for (int j = 0; j < 5; ++j) {
			value = value * 85 + char_array_5[j];
		}
		char_array_4[0] = (value >> 24) & 0xFF;
		char_array_4[1] = (value >> 16) & 0xFF;
		char_array_4[2] = (value >> 8) & 0xFF;
		char_array_4[3] = value & 0xFF;
		for (int i = 0; i < char_count - 1; ++i) {
			output[index++] = char_array_4[i];
		}
	}

	output.resize(index);
	return output;
}
std::string Convert::ToBase85(const std::vector<uint8_t>& input) {
	return ToBase85(std::string((char*)input.data(), input.size()));
}
std::vector<uint8_t> Convert::FromBase85ToBytes(const std::string input) {
	auto tmp = FromBase85(input);
	return std::vector<uint8_t>((uint8_t*)&tmp[0], (uint8_t*)&tmp[0] + tmp.size());
}
std::string Convert::CalcMD5(const void* data, size_t size) {
	MD5 md5;
	md5.update(reinterpret_cast<const uint8_t*>(data), size);
	md5.finalize();
	return md5.hexdigest();
}
std::string Convert::CalcSHA256(const void* data, size_t size) {
	SHA256 sha256;
	sha256.update(reinterpret_cast<const uint8_t*>(data), size);
	sha256.finalize();
	return sha256.hexdigest();
}
std::string Convert::CalcMD5(const std::vector<uint8_t>& data) {
	MD5 md5;
	md5.update(reinterpret_cast<const uint8_t*>(data.data()), data.size());
	md5.finalize();
	return md5.hexdigest();
}
std::string Convert::CalcSHA256(const std::vector<uint8_t>& data) {
	SHA256 sha256;
	sha256.update(reinterpret_cast<const uint8_t*>(data.data()), data.size());
	sha256.finalize();
	return sha256.hexdigest();
}
std::string Convert::CalcMD5(const std::string& data) {
	MD5 md5;
	md5.update(reinterpret_cast<const uint8_t*>(data.data()), data.size());
	md5.finalize();
	return md5.hexdigest();
}
std::string Convert::CalcSHA256(const std::string& data) {
	SHA256 sha256;
	sha256.update(reinterpret_cast<const uint8_t*>(data.data()), data.size());
	sha256.finalize();
	return sha256.hexdigest();
}
int Convert::ToInt32(const std::string input) {
	return atoi(input.c_str());
}
long long Convert::ToInt64(const std::string input) {
	return _atoi64(input.c_str());
}
double Convert::ToFloat(const std::string input) {
	return atof(input.c_str());
}